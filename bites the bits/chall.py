# from Crypto.Util.number import getPrime, bytes_to_long # type: ignore
from sympy import nextprime
# from secret import flag # type: ignore
from binascii import unhexlify

def long_to_bytes (val, endianness='big'):
    """
    Use :ref:`string formatting` and :func:`~binascii.unhexlify` to
    convert ``val``, a :func:`long`, to a byte :func:`str`.

    :param long val: The value to pack

    :param str endianness: The endianness of the result. ``'big'`` for
      big-endian, ``'little'`` for little-endian.

    If you want byte- and word-ordering to differ, you're on your own.

    Using :ref:`string formatting` lets us use Python's C innards.
    """

    # one (1) hex digit per four (4) bits
    width = val.bit_length()

    # unhexlify wants an even multiple of eight (8) bits, but we don't
    # want more digits than we need (hence the ternary-ish 'or')
    width += 8 - ((width % 8) or 8)

    # format width specifier: four (4) bits per hex digit
    fmt = '%%0%dx' % (width // 4)

    # prepend zero (0) to the width, to zero-pad the output
    s = unhexlify(fmt % val)

    if endianness == 'little':
        # see http://stackoverflow.com/a/931095/309233
        s = s[::-1]

    return s

def get_zero_bits(bits):
    return int('0' * bits, 2)

def challenge() :
    p = getPrime(1024)
    p_bits = p.bit_length()
    zero_bits = get_zero_bits(p_bits)
    q = (p | zero_bits) - p + nextprime(p)
    
    n = p*q
    e = 65537
    c = pow(bytes_to_long(flag.encode()), e, n)
    
    print(f"n = {n}")
    print(f"e = {e}")
    print(f"c = {c}")

def mod_inverse(a, m):
    m0, x0, x1 = m, 0, 1
    if m == 1:
        return 0
    while a > 1:
        q = a // m
        m, a = a % m, m
        x0, x1 = x1 - q * x0, x0
    if x1 < 0:
        x1 += m0
    return x1

def mod_exp(base, exp, mod):
    result = 1
    while exp > 0:
        if exp % 2 == 1:
            result = (result * base) % mod
        base = (base * base) % mod
        exp //= 2
    return result

if __name__ == "__main__" :
    c = 17766803113389982780819433274960885186650409736312242807168309159058064732240407133762940588816412263643457637118509637257242134521893396105812226637580484108733190546003430130641486046920539066158172819189364970545284280508063715889262003615982206307883810679243372381366514913175373640163875503985441066590394752132182850859263556327182212843476571359125096141468414513760423765580015963904022891828221723521846742019187170496544913286175376377822420085073801092584300369599721088377777673803666418050367505334807040994034929868133459570558110545120895789401240940509589095320941211728108500179660098074055174380578 
    e = 65537
    n = 19863034877798345965277920400162420854443721380355808586602762628572371063518394849767433012436451934971247084770664520740745300267051598745728963333197550351338477656299403919838653794375281610864554812062488318854371156400919761162982390782383466375998143573974413524171224807790572480659669838414587471981273917460862625872662112934243648338649533346230657790246279637341370503085607096310775300438720406474809582576131089992851031973076280672105763610690429914645923855340081829261842927567646235641890815777467308233674432745148348362268683910562383700033733463389338624851407590677472351928339472185256004040657

    e_inv = mod_inverse(e, n-1)
    f = mod_exp(c, e_inv, n)
    
    byte_string = long_to_bytes(f)
    list_bytes = list(long_to_bytes(f))
    count_dict = {a:list_bytes.count(a) for a in list_bytes}
    print(list_bytes)
    # challenge()
    
# Output
#n = 19863034877798345965277920400162420854443721380355808586602762628572371063518394849767433012436451934971247084770664520740745300267051598745728963333197550351338477656299403919838653794375281610864554812062488318854371156400919761162982390782383466375998143573974413524171224807790572480659669838414587471981273917460862625872662112934243648338649533346230657790246279637341370503085607096310775300438720406474809582576131089992851031973076280672105763610690429914645923855340081829261842927567646235641890815777467308233674432745148348362268683910562383700033733463389338624851407590677472351928339472185256004040657
#e = 65537
#c = 17766803113389982780819433274960885186650409736312242807168309159058064732240407133762940588816412263643457637118509637257242134521893396105812226637580484108733190546003430130641486046920539066158172819189364970545284280508063715889262003615982206307883810679243372381366514913175373640163875503985441066590394752132182850859263556327182212843476571359125096141468414513760423765580015963904022891828221723521846742019187170496544913286175376377822420085073801092584300369599721088377777673803666418050367505334807040994034929868133459570558110545120895789401240940509589095320941211728108500179660098074055174380578
